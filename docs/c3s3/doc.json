{"type":"document","children":[{"type":"heading","children":[{"type":"text","content":"SSTables "},{"type":"emphasis","children":[{"type":"text","content":"p76"}]}],"attributes":{"id":"sstables-p76","level":1}},{"type":"paragraph","children":[{"type":"text","content":"An SSTable ("},{"type":"emphasis","children":[{"type":"text","content":"Sorted String Table"}]},{"type":"text","content":") is essentially just a "},{"type":"emphasis","children":[{"type":"text","content":"Data File Segment"}]},{"type":"text","content":", with the distinction that its keys are stored in sorted order."}]},{"type":"heading","children":[{"type":"text","content":"Pros "},{"type":"emphasis","children":[{"type":"text","content":"p77"}]}],"attributes":{"id":"pros-p77","level":2}},{"type":"list","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"Merging  segments  is  simple  and  efficient,  even  if  the  files  are  bigger  than  the available memory. The process is like "},{"type":"emphasis","children":[{"type":"text","content":"mergesort"}]},{"type":"text","content":" algorithm."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"When meets different values of same keys in several segments, we need to choose one. Since each segment contains all the values written to the database during some period of time, all the values in one segment must be more "},{"type":"strong","children":[{"type":"text","content":"recent"}]},{"type":"text","content":" than all the values in the other segment. We just keep that and discard others."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"In order to query a particular key, we no longer need to load all the keys in cache, instead, since the keys are sorted, we can perform "},{"type":"emphasis","children":[{"type":"text","content":"binary search"}]},{"type":"text","content":". Therefore, only the keys in the feasible interval will be loaded."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"Since queries need to scan over several key-value pairs(the feasible interval) anyway, we can group those records into a block and "},{"type":"strong","children":[{"type":"text","content":"compress"}]},{"type":"text","content":" it. This not only saves the disk space, also reduces the I/O bandwidth use."}]}]}],"attributes":{"ordered":true,"tight":true}},{"type":"heading","children":[{"type":"text","content":"Construction and Maintainess of SSTable "},{"type":"emphasis","children":[{"type":"text","content":"p78"}]}],"attributes":{"id":"construction-and-maintainess-of-sstable-p78","level":2}},{"type":"paragraph","children":[{"type":"text","content":"SSTable is a kind of sorted structure. Maintaining such sorted structure on disk is possible, but it is much easier to maintain it in memory. There are plenty of strutures maintaining order, such as red-black tree ot AVL tree. Typical steps to construct and maintain SSTable are shown below:"}]},{"type":"list","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"Add incoming writes to an in-memory balanced tree data structure. Such structure is sometimes called a "},{"type":"emphasis","children":[{"type":"text","content":"memtable"}]},{"type":"text"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"When the memtable gets bigger than some threshold, write it out to disk as an SSTable. Since tree structures have maintained to some extent sorted data, this procedure can be done efficiently."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"Always try to read from the memtable for requests, then try on-disk segment."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"Merging adn compaction process can run in the background so that it wont affect the incoming writes to the memtable."}]}]}],"attributes":{"ordered":true,"tight":true}},{"type":"paragraph","children":[{"type":"text","content":"The only drawback for this scheme is database crashes. Because it highly relies on the in-memory structure memtable, we will lose it when crash happens. It is also easy to fix it, just as mentioned before, adding snapshots to it. Those snapshots do not need to be sorted, it will only used for recover. That is, idealy, we wont use them very often."}]},{"type":"heading","children":[{"type":"text","content":"LSM-Trees "},{"type":"emphasis","children":[{"type":"text","content":"p78"}]}],"attributes":{"id":"lsm-trees-p78","level":1}},{"type":"blockQuote","children":[{"type":"paragraph","children":[{"type":"text","content":"Before SSTable was introduced by Google, this indexing structure was originally described under the name "},{"type":"emphasis","children":[{"type":"text","content":"Log-Structured Merge-Tree"}]},{"type":"text","content":"(LSM-Tree)"}]}]},{"type":"heading","children":[{"type":"text","content":"Performance Optimizations "},{"type":"emphasis","children":[{"type":"text","content":"p79"}]}],"attributes":{"id":"performance-optimizations-p79","level":1}},{"type":"list","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"If keys do not exist in the database, the memtable and all the segments need to check"}]},{"type":"list","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"use "},{"type":"emphasis","children":[{"type":"text","content":"Bloom Filters"}]},{"type":"text"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"it can tell whether a item is in storage or not"}]}]}],"attributes":{"ordered":false,"tight":true}}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"If SSTables are compacted and merged in arbitrary order and timing, they may consume more storage"}]},{"type":"list","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","content":"like union-find set, those trees can compact based on size and level"}]}]}],"attributes":{"ordered":false,"tight":true}}]}],"attributes":{"ordered":true,"tight":true}}],"attributes":{"date":"2025-09-21","tags":["book","designing data intensive applications"],"title":"SSTables and LSM-Trees"}}