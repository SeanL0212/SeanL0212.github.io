{"version":3,"file":"vendor__radix-ui_react-focus-scope_dist_index.mjs_undefined-B7OpiPAQ.js","sources":["../../frontend/node_modules/@radix-ui/react-focus-scope/dist/index.mjs"],"sourcesContent":["\"use client\";\n\n// src/focus-scope.tsx\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { jsx } from \"react/jsx-runtime\";\nvar AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar EVENT_OPTIONS = { bubbles: false, cancelable: true };\nvar FOCUS_SCOPE_NAME = \"FocusScope\";\nvar FocusScope = React.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current;\n  React.useEffect(() => {\n    if (trapped) {\n      let handleFocusIn2 = function(event) {\n        if (focusScope.paused || !container) return;\n        const target = event.target;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }, handleFocusOut2 = function(event) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget;\n        if (relatedTarget === null) return;\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }, handleMutations2 = function(mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      };\n      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;\n      document.addEventListener(\"focusin\", handleFocusIn2);\n      document.addEventListener(\"focusout\", handleFocusOut2);\n      const mutationObserver = new MutationObserver(handleMutations2);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn2);\n        document.removeEventListener(\"focusout\", handleFocusOut2);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n  const handleKeyDown = React.useCallback(\n    (event) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n      const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement;\n      if (isTabKey && focusedElement) {\n        const container2 = event.currentTarget;\n        const [first, last] = getTabbableEdges(container2);\n        const hasTabbableElementsInside = first && last;\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container2) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n  return /* @__PURE__ */ jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });\n});\nFocusScope.displayName = FOCUS_SCOPE_NAME;\nfunction focusFirst(candidates, { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\nfunction getTabbableEdges(container) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last];\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction findVisible(elements, container) {\n  for (const element of elements) {\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\nfunction isHidden(node, { upTo }) {\n  if (getComputedStyle(node).visibility === \"hidden\") return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo) return false;\n    if (getComputedStyle(node).display === \"none\") return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction focus(element, { select = false } = {}) {\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({ preventScroll: true });\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\nvar focusScopesStack = createFocusScopesStack();\nfunction createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    }\n  };\n}\nfunction arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\nfunction removeLinks(items) {\n  return items.filter((item) => item.tagName !== \"A\");\n}\nvar Root = FocusScope;\nexport {\n  FocusScope,\n  Root\n};\n//# sourceMappingURL=index.mjs.map\n"],"names":["AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","FOCUS_SCOPE_NAME","FocusScope","React.forwardRef","props","forwardedRef","loop","trapped","onMountAutoFocusProp","onUnmountAutoFocusProp","scopeProps","container","setContainer","React.useState","onMountAutoFocus","useCallbackRef","onUnmountAutoFocus","lastFocusedElementRef","React.useRef","composedRefs","useComposedRefs","node","focusScope","React.useEffect","handleFocusIn2","event","target","focus","handleFocusOut2","relatedTarget","handleMutations2","mutations","mutation","mutationObserver","focusScopesStack","previouslyFocusedElement","mountEvent","focusFirst","removeLinks","getTabbableCandidates","unmountEvent","handleKeyDown","React.useCallback","isTabKey","focusedElement","container2","first","last","getTabbableEdges","jsx","Primitive","candidates","select","candidate","findVisible","nodes","walker","isHiddenInput","elements","element","isHidden","upTo","isSelectableInput","createFocusScopesStack","stack","activeFocusScope","arrayRemove","array","item","updatedArray","index","items"],"mappings":"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","x_google_ignoreList":[0]}